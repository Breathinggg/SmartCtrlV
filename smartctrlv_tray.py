# smartctrlv_tray.py# -*- coding: utf-8 -*-"""SmartCtrlV 托盘前端（三语版，子进程方案）- 使用 PySide6 实现 Snipaste 风格常驻托盘图标- 后台逻辑通过子进程运行 smartctrlv_main.py- 托盘菜单可以控制：    * Explorer 增强总开关    * 多格式粘贴菜单总开关    * 菜单白名单开关    * 开机自启动    * 打开设置 / 配置文件 / 日志目录 / 重启后台 / 退出- 设置窗口里可以调整：    * Explorer 子功能开关    * 菜单开关、白名单、热键、白名单进程列表    * 菜单内容选项（写入 config["menu"]["options"]，后端可在 Tk 菜单里接入）多语言说明：    - config["ui"]["language"] = "auto" | "zh" | "ja" | "en"    - "auto" 时根据系统语言自动选择：中文 / 日本语 / English"""import smartctrlv_main  # 你这个主文件的名字import osimport sysimport jsonimport subprocessimport signalimport ctypesimport tracebackfrom PySide6.QtWidgets import (    QApplication,    QSystemTrayIcon,    QMenu,    QDialog,    QVBoxLayout,    QHBoxLayout,    QLabel,    QPushButton,    QCheckBox,    QLineEdit,    QListWidget,    QListWidgetItem,    QWidget,    QMessageBox,)from PySide6.QtGui import QIcon, QAction, QPixmapfrom PySide6.QtCore import QObject, Qt, QCoreApplication, QLocalefrom PySide6.QtGui import QIcon, QAction, QPixmap, QKeySequencefrom PySide6.QtCore import QObject, Qt, QCoreApplication, QLocale, Signal# Windows 开机自启动try:    import winreg  # type: ignoreexcept ImportError:    winreg = NoneAPP_VERSION = "v1.0.0"APP_NAME = "SmartCtrlV"TRAY_APP_NAME = "SmartCtrlVTray"CORE_SCRIPT_NAME = "smartctrlv_main.py"import sysimport osimport threading  # 新增IS_FROZEN = getattr(sys, "frozen", False)  # 新增：判断是否是 PyInstaller 打包后的 exedef get_base_dir():    # 如果是打包成 exe 运行，sys.frozen = True    if getattr(sys, 'frozen', False):        return os.path.dirname(sys.executable)    # 普通 Python 运行    return os.path.dirname(os.path.abspath(__file__))def resource_path(relative_path: str) -> str:    """    打包成 exe 之后/平时运行时，都能正确找到资源文件（比如图标）    """    if hasattr(sys, "frozen"):  # PyInstaller 打包后的 exe        base_path = sys._MEIPASS    else:  # 普通 .py 运行        base_path = os.path.dirname(os.path.abspath(__file__))    return os.path.join(base_path, relative_path)SCRIPT_DIR = get_base_dir()CONFIG_PATH = os.path.join(SCRIPT_DIR, "smartctrlv_config.json")LOG_DIR = SCRIPT_DIR  # 暂时就用脚本目录当“日志目录”# ===================== 多语言字典 =====================I18N = {    "zh": {        "tray_tooltip": f"{APP_NAME} {APP_VERSION}",        "menu_status": "状态 / 使用说明",        "menu_enable_explorer": "启用 Explorer 增强",        "menu_enable_menu": "启用多格式粘贴菜单",        "menu_enable_whitelist": "菜单白名单生效",        "menu_open_settings": "打开设置...",        "menu_open_config": "打开配置文件",        "menu_open_logs": "打开日志目录",        "menu_autostart": "开机自启动",        "menu_restart_core": "重启后台进程",        "menu_quit": "退出",        "menu_language": "语言 / Language / 言語",        "menu_lang_auto": "自动（跟随系统）",        "menu_lang_zh": "简体中文",        "menu_lang_ja": "日本語",        "menu_lang_en": "English",        "status_title": f"{APP_NAME} 状态",        "status_text": (            "{app} {ver}\n\n"            "配置文件：{config}\n\n"            "当前功能状态：\n"            "- Explorer 增强：{explorer}\n"            "- 多格式粘贴菜单：{menu}\n"            "- 菜单白名单：{whitelist}\n\n"            "后台进程：{core}\n\n"            "提示：\n"            "- 在资源管理器里 Ctrl+V：智能处理命令 / 文件名 / 写入文本文件\n"            "- Ctrl+Alt+V：打开多格式粘贴菜单（默认仅在白名单应用中）\n"            "- Ctrl+Shift+V：AI 智能粘贴（终端 / 编辑器中只粘命令或代码）\n"            "- Ctrl+Alt+Esc：紧急退出后台（由 smartctrlv_main.py 处理）"        ),        "on": "开启",        "off": "关闭",        "core_running": "运行中",        "core_stopped": "未运行",        "settings_title": f"{APP_NAME} 设置",        "settings_header": f"{APP_NAME} {APP_VERSION} 设置",        "settings_explorer_section": "Explorer 增强：",        "settings_explorer_enable": "启用 Explorer 增强",        "settings_explorer_cmd": "启用：剪贴板命令 -> CMD 执行",        "settings_explorer_create": "启用：按行创建空文件",        "settings_explorer_write": "启用：选中文本文件时写入",        "settings_explorer_hotkey_hint": "Explorer Ctrl+V 热键：",        "settings_menu_section": "多格式粘贴菜单：",        "settings_menu_enable": "启用多格式粘贴菜单（menu.enabled）",        "settings_menu_whitelist": "启用白名单（menu.whitelist_enabled）",        "settings_menu_hotkey_label": "菜单热键：",        "settings_menu_whitelist_label": "白名单进程（exe 名，双击可编辑）：",        "settings_menu_add": "添加",        "settings_menu_remove": "删除选中",        "settings_options_section": "菜单条目开关（写入 config['menu']['options']）：",        "settings_opt_raw": "原样粘贴",        "settings_opt_plain": "纯文本粘贴",        "settings_opt_md": "Markdown 清理粘贴",        "settings_opt_struct": "结构化格式化(JSON/XML/HTML/SQL)",        "settings_opt_collapse": "去所有空行粘贴",        "settings_opt_py": "Python 缩进整理粘贴",        "settings_save": "保存并应用",        "settings_cancel": "取消",        "msg_config_missing_title": APP_NAME,        "msg_config_missing": "配置文件不存在，稍后会自动生成。\n路径：\n{path}",        "msg_logdir_missing": "日志目录不存在：\n{path}",        "msg_autostart_not_supported": "当前环境不支持注册表方式开机自启动。",        "msg_autostart_failed": "设置开机自启动失败：\n{err}",        "msg_core_not_found": "未找到核心脚本 {name}\n请确认它与本托盘程序位于同一目录。",        "msg_core_start_failed": "启动后台进程失败：\n{err}",    },    "ja": {        "tray_tooltip": f"{APP_NAME} {APP_VERSION}",        "menu_status": "状態 / 使い方",        "menu_enable_explorer": "Explorer 拡張を有効にする",        "menu_enable_menu": "多機能ペーストメニューを有効にする",        "menu_enable_whitelist": "メニューのホワイトリストを有効にする",        "menu_open_settings": "設定を開く...",        "menu_open_config": "設定ファイルを開く",        "menu_open_logs": "ログフォルダを開く",        "menu_autostart": "Windows 起動時に自動起動",        "menu_restart_core": "バックグラウンドを再起動",        "menu_quit": "終了",        "menu_language": "言語 / Language / 语言",        "menu_lang_auto": "自動（システムに合わせる）",        "menu_lang_zh": "簡体字中国語",        "menu_lang_ja": "日本語",        "menu_lang_en": "English",        "status_title": f"{APP_NAME} 状態",        "status_text": (            "{app} {ver}\n\n"            "設定ファイル：{config}\n\n"            "現在の機能状態：\n"            "- Explorer 拡張：{explorer}\n"            "- 多機能ペーストメニュー：{menu}\n"            "- メニューのホワイトリスト：{whitelist}\n\n"            "バックグラウンドプロセス：{core}\n\n"            "ヒント：\n"            "- Explorer で Ctrl+V：コマンド / ファイル名 / テキストファイルへの書き込みを自動判定\n"            "- Ctrl+Alt+V：多機能ペーストメニューを開く（デフォルトではホワイトリストアプリのみ）\n"            "- Ctrl+Shift+V：AI スマートペースト（ターミナル / エディタではコマンドやコードのみ貼り付け）\n"            "- Ctrl+Alt+Esc：バックグラウンドを緊急終了（smartctrlv_main.py 側で処理）"        ),        "on": "オン",        "off": "オフ",        "core_running": "実行中",        "core_stopped": "停止中",        "settings_title": f"{APP_NAME} 設定",        "settings_header": f"{APP_NAME} {APP_VERSION} 設定",        "settings_explorer_section": "Explorer 拡張：",        "settings_explorer_enable": "Explorer 拡張を有効にする",        "settings_explorer_cmd": "クリップボードのコマンドを CMD で実行",        "settings_explorer_create": "行ごとに空ファイルを作成",        "settings_explorer_write": "選択中のテキストファイルに書き込む",        "settings_explorer_hotkey_hint": "Explorer Ctrl+V ショートカット：",        "settings_menu_section": "多機能ペーストメニュー：",        "settings_menu_enable": "多機能ペーストメニューを有効にする（menu.enabled）",        "settings_menu_whitelist": "ホワイトリストを有効にする（menu.whitelist_enabled）",        "settings_menu_hotkey_label": "メニューのホットキー：",        "settings_menu_whitelist_label": "ホワイトリストのプロセス（exe 名、ダブルクリックで編集）：",        "settings_menu_add": "追加",        "settings_menu_remove": "選択を削除",        "settings_options_section": "メニュー項目の有効/無効（config['menu']['options'] に保存）：",        "settings_opt_raw": "そのまま貼り付け",        "settings_opt_plain": "プレーンテキストで貼り付け",        "settings_opt_md": "Markdown を整形して貼り付け",        "settings_opt_struct": "構造化フォーマット(JSON/XML/HTML/SQL)",        "settings_opt_collapse": "空行をすべて削除して貼り付け",        "settings_opt_py": "Python インデントを整理して貼り付け",        "settings_save": "保存して適用",        "settings_cancel": "キャンセル",        "msg_config_missing_title": APP_NAME,        "msg_config_missing": "設定ファイルが存在しません。後で自動生成されます。\nパス：\n{path}",        "msg_logdir_missing": "ログフォルダが存在しません：\n{path}",        "msg_autostart_not_supported": "現在の環境ではレジストリを使った自動起動設定はサポートされていません。",        "msg_autostart_failed": "自動起動の設定に失敗しました：\n{err}",        "msg_core_not_found": "コアスクリプト {name} が見つかりません。\n本トレイアプリと同じフォルダに配置してください。",        "msg_core_start_failed": "バックグラウンドプロセスの起動に失敗しました：\n{err}",    },    "en": {        "tray_tooltip": f"{APP_NAME} {APP_VERSION}",        "menu_status": "Status / Help",        "menu_enable_explorer": "Enable Explorer enhancements",        "menu_enable_menu": "Enable multi-format paste menu",        "menu_enable_whitelist": "Enable menu whitelist",        "menu_open_settings": "Open settings...",        "menu_open_config": "Open config file",        "menu_open_logs": "Open log directory",        "menu_autostart": "Run at system startup",        "menu_restart_core": "Restart backend process",        "menu_quit": "Quit",        "menu_language": "Language / 言語 / 语言",        "menu_lang_auto": "Auto (follow system)",        "menu_lang_zh": "Simplified Chinese",        "menu_lang_ja": "Japanese",        "menu_lang_en": "English",        "status_title": f"{APP_NAME} Status",        "status_text": (            "{app} {ver}\n\n"            "Config file: {config}\n\n"            "Current feature status:\n"            "- Explorer enhancements: {explorer}\n"            "- Multi-format paste menu: {menu}\n"            "- Menu whitelist: {whitelist}\n\n"            "Backend process: {core}\n\n"            "Tips:\n"            "- In Explorer, Ctrl+V: smart handling of commands / file names / writing to text files\n"            "- Ctrl+Alt+V: open multi-format paste menu (by default only in whitelisted apps)\n"            "- Ctrl+Shift+V: AI smart paste (only commands/code in terminal/editors)\n"            "- Ctrl+Alt+Esc: emergency exit of backend (handled by smartctrlv_main.py)"        ),        "on": "On",        "off": "Off",        "core_running": "Running",        "core_stopped": "Not running",        "settings_title": f"{APP_NAME} Settings",        "settings_header": f"{APP_NAME} {APP_VERSION} Settings",        "settings_explorer_section": "Explorer enhancements:",        "settings_explorer_enable": "Enable Explorer enhancements",        "settings_explorer_cmd": "Enable: clipboard commands -> CMD execution",        "settings_explorer_create": "Enable: create empty files line by line",        "settings_explorer_write": "Enable: write clipboard text to selected file",        "settings_explorer_hotkey_hint": "Explorer Ctrl+V hotkey:",        "settings_menu_section": "Multi-format paste menu:",        "settings_menu_enable": "Enable multi-format paste menu (menu.enabled)",        "settings_menu_whitelist": "Enable whitelist (menu.whitelist_enabled)",        "settings_menu_hotkey_label": "Menu hotkey:",        "settings_menu_whitelist_label": "Whitelist processes (exe names, double click to edit):",        "settings_menu_add": "Add",        "settings_menu_remove": "Remove selected",        "settings_options_section": "Menu item switches (saved to config['menu']['options']):",        "settings_opt_raw": "Raw paste",        "settings_opt_plain": "Plain text paste",        "settings_opt_md": "Markdown cleanup paste",        "settings_opt_struct": "Structured format (JSON/XML/HTML/SQL)",        "settings_opt_collapse": "Remove all blank lines",        "settings_opt_py": "Python dedent paste",        "settings_save": "Save & apply",        "settings_cancel": "Cancel",        "msg_config_missing_title": APP_NAME,        "msg_config_missing": "Config file not found. It will be created later.\nPath:\n{path}",        "msg_logdir_missing": "Log directory not found:\n{path}",        "msg_autostart_not_supported": "Autostart via registry is not supported in this environment.",        "msg_autostart_failed": "Failed to set autostart:\n{err}",        "msg_core_not_found": "Core script {name} not found.\nPlease put it in the same folder as this tray app.",        "msg_core_start_failed": "Failed to start backend process:\n{err}",    },}def tr(lang: str, key: str, **kwargs) -> str:    """简单多语言翻译辅助函数"""    d = I18N.get(lang, I18N["en"])    text = d.get(key, I18N["en"].get(key, key))    if kwargs:        try:            return text.format(**kwargs)        except Exception:            return text    return text# ===================== 默认配置（加 ui.language） =====================DEFAULT_CONFIG = {    "ui": {        "language": "auto",  # "auto" | "zh" | "ja" | "en"    },    "explorer": {        "enabled": True,        "enable_command_from_clipboard": True,        "enable_create_files_from_clipboard": True,        "enable_write_file_from_clipboard": True,        "text_ext_whitelist": [            ".txt",            ".md",            ".markdown",            ".log",            ".json",            ".yaml",            ".yml",            ".ini",            ".cfg",            ".py",            ".js",            ".ts",            ".java",            ".c",            ".cpp",            ".cs",        ],    },    "menu": {        "enabled": True,        "whitelist_enabled": True,        "whitelist_processes": [            "notepad.exe",            "chrome.exe",            "msedge.exe",            "firefox.exe",            "code.exe",            "winword.exe",            "excel.exe",            "powerpnt.exe",            "wechat.exe",            "qq.exe",        ],        "hotkey": "ctrl+alt+v",        "options": {            "raw": True,            "plain": True,            "markdown": True,            "structured": True,            "collapse_blank": True,            "python_dedent": True,        },    },    "hotkeys": {        "explorer_ctrl_v": "ctrl+v",    },}def deep_update(base: dict, override: dict):    """简单深层合并 dict，用 override 覆盖 base"""    for k, v in override.items():        if isinstance(v, dict) and isinstance(base.get(k), dict):            deep_update(base[k], v)        else:            base[k] = vdef detect_system_lang() -> str:    """根据系统语言推断 'zh' / 'ja' / 'en'"""    loc = QLocale.system()    lang_enum = loc.language()    # 尽量兼容不同 Qt 版本    try:        from PySide6.QtCore import QLocale as _QL        if lang_enum in (            _QL.Chinese,            getattr(_QL, "ChineseSimplified", _QL.Chinese),            getattr(_QL, "TaiwanChinese", _QL.Chinese),            getattr(_QL, "HongKongChinese", _QL.Chinese),        ):            return "zh"        if lang_enum == _QL.Japanese:            return "ja"    except Exception:        name = loc.name().lower()  # 例如 zh_CN / ja_JP / en_US        if name.startswith("zh"):            return "zh"        if name.startswith("ja"):            return "ja"    return "en"def get_effective_lang(config: dict) -> str:    ui = config.get("ui", {})    setting = ui.get("language", "auto")    if setting in ("zh", "ja", "en"):        return setting    # auto    return detect_system_lang()# ===================== 设置窗口 =====================class SettingsDialog(QDialog):    """    设置窗口：        - Explorer 功能开关        - 菜单开关 / 白名单 / 热键        - 菜单内容选项    """    def __init__(self, parent, lang: str, config: dict):        super().__init__(parent)        self.lang = lang        self.setWindowTitle(tr(lang, "settings_title"))        self.setWindowModality(Qt.ApplicationModal)        self.resize(480, 520)        # 在内存里操作一份副本        self._config = json.loads(json.dumps(config))        layout = QVBoxLayout(self)        layout.addWidget(QLabel(tr(lang, "settings_header"), self))        # ===== Explorer 区块 =====        explorer_group = QWidget(self)        explorer_layout = QVBoxLayout(explorer_group)        explorer_layout.setContentsMargins(0, 0, 0, 0)        explorer_layout.addWidget(QLabel(tr(lang, "settings_explorer_section"), explorer_group))        self.chk_explorer_enabled = QCheckBox(tr(lang, "settings_explorer_enable"), explorer_group)        self.chk_explorer_cmd = QCheckBox(tr(lang, "settings_explorer_cmd"), explorer_group)        self.chk_explorer_create = QCheckBox(tr(lang, "settings_explorer_create"), explorer_group)        self.chk_explorer_write = QCheckBox(tr(lang, "settings_explorer_write"), explorer_group)        exp_cfg = self._config.get("explorer", {})        self.chk_explorer_enabled.setChecked(exp_cfg.get("enabled", True))        self.chk_explorer_cmd.setChecked(exp_cfg.get("enable_command_from_clipboard", True))        self.chk_explorer_create.setChecked(exp_cfg.get("enable_create_files_from_clipboard", True))        self.chk_explorer_write.setChecked(exp_cfg.get("enable_write_file_from_clipboard", True))        explorer_layout.addWidget(self.chk_explorer_enabled)        explorer_layout.addWidget(self.chk_explorer_cmd)        explorer_layout.addWidget(self.chk_explorer_create)        explorer_layout.addWidget(self.chk_explorer_write)        # Explorer Ctrl+V 热键行        hotkeys_cfg = self._config.get("hotkeys", {})        explorer_hotkey_row = QHBoxLayout()        explorer_hotkey_row.addWidget(QLabel(tr(lang, "settings_explorer_hotkey_hint"), explorer_group))        self.edit_explorer_hotkey = HotkeyLineEdit(explorer_group)        self.edit_explorer_hotkey.setHotkey(            hotkeys_cfg.get("explorer_ctrl_v", "ctrl+v")        )        explorer_hotkey_row.addWidget(self.edit_explorer_hotkey)        explorer_layout.addLayout(explorer_hotkey_row)        layout.addWidget(explorer_group)        # ===== 菜单配置 =====        menu_group = QWidget(self)        menu_layout = QVBoxLayout(menu_group)        menu_layout.setContentsMargins(0, 16, 0, 0)        menu_layout.addWidget(QLabel(tr(lang, "settings_menu_section"), menu_group))        self.chk_menu_enabled = QCheckBox(tr(lang, "settings_menu_enable"), menu_group)        self.chk_menu_whitelist = QCheckBox(tr(lang, "settings_menu_whitelist"), menu_group)        menu_cfg = self._config.get("menu", {})        self.chk_menu_enabled.setChecked(menu_cfg.get("enabled", True))        self.chk_menu_whitelist.setChecked(menu_cfg.get("whitelist_enabled", True))        menu_layout.addWidget(self.chk_menu_enabled)        menu_layout.addWidget(self.chk_menu_whitelist)        # 菜单热键        hotkey_row = QHBoxLayout()        hotkey_row.addWidget(QLabel(tr(lang, "settings_menu_hotkey_label"), menu_group))        self.edit_menu_hotkey = HotkeyLineEdit(menu_group)        self.edit_menu_hotkey.setHotkey(menu_cfg.get("hotkey", "ctrl+alt+v"))        hotkey_row.addWidget(self.edit_menu_hotkey)        menu_layout.addLayout(hotkey_row)        # 白名单列表编辑        menu_layout.addWidget(QLabel(tr(lang, "settings_menu_whitelist_label"), menu_group))        self.list_whitelist = QListWidget(menu_group)        for p in menu_cfg.get("whitelist_processes", []):            item = QListWidgetItem(p)            self.list_whitelist.addItem(item)        menu_layout.addWidget(self.list_whitelist)        btn_row = QHBoxLayout()        btn_add = QPushButton(tr(lang, "settings_menu_add"), menu_group)        btn_remove = QPushButton(tr(lang, "settings_menu_remove"), menu_group)        btn_row.addWidget(btn_add)        btn_row.addWidget(btn_remove)        menu_layout.addLayout(btn_row)        def add_process():            text = "newapp.exe"            item = QListWidgetItem(text)            self.list_whitelist.addItem(item)            self.list_whitelist.editItem(item)        def remove_selected():            for item in self.list_whitelist.selectedItems():                self.list_whitelist.takeItem(self.list_whitelist.row(item))        btn_add.clicked.connect(add_process)        btn_remove.clicked.connect(remove_selected)        layout.addWidget(menu_group)        # ===== 菜单内容选项 =====        options_group = QWidget(self)        options_layout = QVBoxLayout(options_group)        options_layout.setContentsMargins(0, 16, 0, 0)        options_layout.addWidget(QLabel(tr(lang, "settings_options_section"), options_group))        opts_cfg = menu_cfg.get("options", {})        self.chk_opt_raw = QCheckBox(tr(lang, "settings_opt_raw"), options_group)        self.chk_opt_plain = QCheckBox(tr(lang, "settings_opt_plain"), options_group)        self.chk_opt_md = QCheckBox(tr(lang, "settings_opt_md"), options_group)        self.chk_opt_struct = QCheckBox(tr(lang, "settings_opt_struct"), options_group)        self.chk_opt_collapse = QCheckBox(tr(lang, "settings_opt_collapse"), options_group)        self.chk_opt_py = QCheckBox(tr(lang, "settings_opt_py"), options_group)        self.chk_opt_raw.setChecked(opts_cfg.get("raw", True))        self.chk_opt_plain.setChecked(opts_cfg.get("plain", True))        self.chk_opt_md.setChecked(opts_cfg.get("markdown", True))        self.chk_opt_struct.setChecked(opts_cfg.get("structured", True))        self.chk_opt_collapse.setChecked(opts_cfg.get("collapse_blank", True))        self.chk_opt_py.setChecked(opts_cfg.get("python_dedent", True))        options_layout.addWidget(self.chk_opt_raw)        options_layout.addWidget(self.chk_opt_plain)        options_layout.addWidget(self.chk_opt_md)        options_layout.addWidget(self.chk_opt_struct)        options_layout.addWidget(self.chk_opt_collapse)        options_layout.addWidget(self.chk_opt_py)        layout.addWidget(options_group)        # ===== 按钮 =====        btns = QHBoxLayout()        btn_save = QPushButton(tr(lang, "settings_save"), self)        btn_cancel = QPushButton(tr(lang, "settings_cancel"), self)        btns.addStretch(1)        btns.addWidget(btn_save)        btns.addWidget(btn_cancel)        layout.addLayout(btns)        btn_save.clicked.connect(self.accept)        btn_cancel.clicked.connect(self.reject)    def get_config(self) -> dict:        """把对话框里的控件状态写回到 config 副本并返回"""        cfg = self._config        # Explorer        exp = cfg.setdefault("explorer", {})        exp["enabled"] = self.chk_explorer_enabled.isChecked()        exp["enable_command_from_clipboard"] = self.chk_explorer_cmd.isChecked()        exp["enable_create_files_from_clipboard"] = self.chk_explorer_create.isChecked()        exp["enable_write_file_from_clipboard"] = self.chk_explorer_write.isChecked()        # 菜单        menu = cfg.setdefault("menu", {})        menu["enabled"] = self.chk_menu_enabled.isChecked()        menu["whitelist_enabled"] = self.chk_menu_whitelist.isChecked()        menu["hotkey"] = self.edit_menu_hotkey.text().strip() or "ctrl+alt+v"        # ⭐⭐ 关键：把六个 options 都写回去 ⭐⭐        opts = menu.setdefault("options", {})        opts["raw"] = self.chk_opt_raw.isChecked()        opts["plain"] = self.chk_opt_plain.isChecked()        opts["markdown"] = self.chk_opt_md.isChecked()        opts["structured"] = self.chk_opt_struct.isChecked()        opts["collapse_blank"] = self.chk_opt_collapse.isChecked()        opts["python_dedent"] = self.chk_opt_py.isChecked()        # 如果你已经加了热键设置，也一并写回        hotkeys = cfg.setdefault("hotkeys", {})        hotkeys["explorer_ctrl_v"] = self.edit_explorer_hotkey.text().strip() or "ctrl+v"        return cfgclass HotkeyLineEdit(QLineEdit):    """    只用于录入热键：    - 用户按下组合键（Ctrl / Alt / Shift + 任意键）    - 自动转成 keyboard 库能吃的字符串，例如：ctrl+alt+v, ctrl+shift+f8    - 不需要用户手动打字    """    hotkeyChanged = Signal(str)    def __init__(self, parent=None):        super().__init__(parent)        self.setReadOnly(True)        # 不允许打字，只能按键        self._current = ""    def setHotkey(self, hotkey: str):        self._current = hotkey or ""        self.setText(self._current)    def keyPressEvent(self, event):        # Esc -> 取消本次修改，还原        if event.key() == Qt.Key_Escape:            self.setText(self._current)            return        # 只按下修饰键时先不处理        if event.key() in (Qt.Key_Control, Qt.Key_Shift, Qt.Key_Alt, Qt.Key_Meta):            return        mods = []        if event.modifiers() & Qt.ControlModifier:            mods.append("ctrl")        if event.modifiers() & Qt.ShiftModifier:            mods.append("shift")        if event.modifiers() & Qt.AltModifier:            mods.append("alt")        # 基础按键名        key = event.key()        key_text = QKeySequence(key).toString()        key_text = key_text.lower()        if not key_text:            # 极端情况兜底            if 32 <= key <= 126:                key_text = chr(key).lower()            else:                key_text = hex(key)        combo = "+".join(mods + [key_text]) if mods else key_text        self._current = combo        self.setText(combo)        self.hotkeyChanged.emit(combo)# ===================== 托盘应用 =====================class TrayApp(QObject):    def __init__(self, app: QApplication):        super().__init__()        self.app = app        self.config = self.load_or_create_config()        self.lang = get_effective_lang(self.config)        self.core_proc: subprocess.Popen | None = None        self.tray = QSystemTrayIcon(self)        self.tray.setIcon(self.create_icon())        self.tray.setToolTip(tr(self.lang, "tray_tooltip"))        self.menu = QMenu()        # 状态动作        self.action_show_status = QAction(self.menu)        self.action_show_status.triggered.connect(self.show_status_dialog)        self.menu.addAction(self.action_show_status)        self.menu.addSeparator()        # Explorer 增强总开关        self.action_explorer_enable = QAction(self.menu)        self.action_explorer_enable.setCheckable(True)        self.action_explorer_enable.setChecked(            self.config.get("explorer", {}).get("enabled", True)        )        self.action_explorer_enable.toggled.connect(self.on_toggle_explorer_enabled)        self.menu.addAction(self.action_explorer_enable)        # 多格式菜单总开关        self.action_menu_enable = QAction(self.menu)        self.action_menu_enable.setCheckable(True)        self.action_menu_enable.setChecked(            self.config.get("menu", {}).get("enabled", True)        )        self.action_menu_enable.toggled.connect(self.on_toggle_menu_enabled)        self.menu.addAction(self.action_menu_enable)        # 菜单白名单生效        self.action_menu_whitelist = QAction(self.menu)        self.action_menu_whitelist.setCheckable(True)        self.action_menu_whitelist.setChecked(            self.config.get("menu", {}).get("whitelist_enabled", True)        )        self.action_menu_whitelist.toggled.connect(self.on_toggle_menu_whitelist)        self.menu.addAction(self.action_menu_whitelist)        self.menu.addSeparator()        # 打开设置窗口        self.action_open_settings = QAction(self.menu)        self.action_open_settings.triggered.connect(self.open_settings_dialog)        self.menu.addAction(self.action_open_settings)        # 打开配置文件        self.action_open_config = QAction(self.menu)        self.action_open_config.triggered.connect(self.open_config_file)        self.menu.addAction(self.action_open_config)        # 打开日志目录        self.action_open_logs = QAction(self.menu)        self.action_open_logs.triggered.connect(self.open_log_dir)        self.menu.addAction(self.action_open_logs)        self.menu.addSeparator()        # 语言子菜单        self.submenu_lang = QMenu(self.menu)        self.action_lang_auto = QAction(self.menu, checkable=True)        self.action_lang_zh = QAction(self.menu, checkable=True)        self.action_lang_ja = QAction(self.menu, checkable=True)        self.action_lang_en = QAction(self.menu, checkable=True)        self.action_lang_auto.triggered.connect(lambda: self.set_language("auto"))        self.action_lang_zh.triggered.connect(lambda: self.set_language("zh"))        self.action_lang_ja.triggered.connect(lambda: self.set_language("ja"))        self.action_lang_en.triggered.connect(lambda: self.set_language("en"))        self.submenu_lang.addAction(self.action_lang_auto)        self.submenu_lang.addSeparator()        self.submenu_lang.addAction(self.action_lang_zh)        self.submenu_lang.addAction(self.action_lang_ja)        self.submenu_lang.addAction(self.action_lang_en)        self.menu.addMenu(self.submenu_lang)        self.menu.addSeparator()        # 开机自启动        self.action_autostart = QAction(self.menu)        self.action_autostart.setCheckable(True)        self.action_autostart.setChecked(self.is_autostart_enabled())        self.action_autostart.toggled.connect(self.on_toggle_autostart)        self.menu.addAction(self.action_autostart)        self.menu.addSeparator()        # 后台重启        self.action_restart_core = QAction(self.menu)        self.action_restart_core.triggered.connect(self.restart_core)        self.menu.addAction(self.action_restart_core)        # 退出        self.action_quit = QAction(self.menu)        self.action_quit.triggered.connect(self.exit_app)        self.menu.addAction(self.action_quit)        self.tray.setContextMenu(self.menu)        self.tray.show()        # 左键双击 -> 打开状态窗口        self.tray.activated.connect(self.on_tray_activated)        # 根据语言更新所有菜单文字        self.update_ui_texts()        # 启动后台 core 逻辑        if IS_FROZEN:            # 打包成 exe 后：不要再起子进程，否则会不停启动自己            threading.Thread(                target=smartctrlv_main.main,  # 直接跑你 main 里的主循环/注册热键                daemon=True,            ).start()        else:            # 开发阶段：还是用原来的子进程方案            self.start_core()    # ---------- 配置 & 文件 ----------    def load_or_create_config(self) -> dict:        cfg = json.loads(json.dumps(DEFAULT_CONFIG))        if os.path.exists(CONFIG_PATH):            try:                with open(CONFIG_PATH, "r", encoding="utf-8") as f:                    user_cfg = json.load(f)                deep_update(cfg, user_cfg)            except Exception as e:                print("[Tray] 读取配置失败，将使用默认配置:", e)                traceback.print_exc()        else:            # 写一份默认配置            self.save_config(cfg)        return cfg    def save_config(self, cfg: dict | None = None):        if cfg is None:            cfg = self.config        try:            with open(CONFIG_PATH, "w", encoding="utf-8") as f:                json.dump(cfg, f, indent=2, ensure_ascii=False)        except Exception as e:            print("[Tray] 写入配置失败:", e)            traceback.print_exc()    # ---------- 语言 & 文本刷新 ----------    def update_ui_texts(self):        lang = self.lang        self.tray.setToolTip(tr(lang, "tray_tooltip"))        self.action_show_status.setText(tr(lang, "menu_status"))        self.action_explorer_enable.setText(tr(lang, "menu_enable_explorer"))        self.action_menu_enable.setText(tr(lang, "menu_enable_menu"))        self.action_menu_whitelist.setText(tr(lang, "menu_enable_whitelist"))        self.action_open_settings.setText(tr(lang, "menu_open_settings"))        self.action_open_config.setText(tr(lang, "menu_open_config"))        self.action_open_logs.setText(tr(lang, "menu_open_logs"))        self.action_autostart.setText(tr(lang, "menu_autostart"))        self.action_restart_core.setText(tr(lang, "menu_restart_core"))        self.action_quit.setText(tr(lang, "menu_quit"))        self.submenu_lang.setTitle(tr(lang, "menu_language"))        self.action_lang_auto.setText(tr(lang, "menu_lang_auto"))        self.action_lang_zh.setText(tr(lang, "menu_lang_zh"))        self.action_lang_ja.setText(tr(lang, "menu_lang_ja"))        self.action_lang_en.setText(tr(lang, "menu_lang_en"))        # 更新语言选中状态        lang_setting = self.config.get("ui", {}).get("language", "auto")        self.action_lang_auto.setChecked(lang_setting == "auto")        self.action_lang_zh.setChecked(lang_setting == "zh")        self.action_lang_ja.setChecked(lang_setting == "ja")        self.action_lang_en.setChecked(lang_setting == "en")    def set_language(self, lang_setting: str):        self.config.setdefault("ui", {})["language"] = lang_setting        self.lang = get_effective_lang(self.config)        self.save_config()        self.update_ui_texts()    # ---------- 图标 / UI ----------    def create_icon(self) -> QIcon:        # 使用打包进去的 smartctrlv.ico 作为托盘图标        icon_path = resource_path("smartctrlv.ico")        return QIcon(icon_path)    def on_tray_activated(self, reason: QSystemTrayIcon.ActivationReason):        if reason == QSystemTrayIcon.DoubleClick:            self.show_status_dialog()    def show_status_dialog(self):        lang = self.lang        dlg = QDialog()        dlg.setWindowTitle(tr(lang, "status_title"))        dlg.setWindowModality(Qt.ApplicationModal)        layout = QVBoxLayout(dlg)        explorer_on = tr(lang, "on") if self.config.get("explorer", {}).get("enabled", True) else tr(lang, "off")        menu_on = tr(lang, "on") if self.config.get("menu", {}).get("enabled", True) else tr(lang, "off")        wl_on = tr(lang, "on") if self.config.get("menu", {}).get("whitelist_enabled", True) else tr(lang, "off")        core_on = tr(lang, "core_running") if (self.core_proc and self.core_proc.poll() is None) else tr(lang, "core_stopped")        text = tr(            lang,            "status_text",            app=APP_NAME,            ver=APP_VERSION,            config=CONFIG_PATH,            explorer=explorer_on,            menu=menu_on,            whitelist=wl_on,            core=core_on,        )        lbl = QLabel(dlg)        lbl.setText(text)        lbl.setWordWrap(True)        layout.addWidget(lbl)        btn_close = QPushButton("OK" if lang == "en" else "关闭" if lang == "zh" else "閉じる", dlg)        btn_close.clicked.connect(dlg.accept)        layout.addWidget(btn_close, alignment=Qt.AlignRight)        dlg.exec()    def open_settings_dialog(self):        dlg = SettingsDialog(None, self.lang, self.config)        if dlg.exec() == QDialog.Accepted:            new_cfg = dlg.get_config()            # 更新内存配置            self.config = new_cfg            # 同步托盘上的几个勾选状态            self.action_explorer_enable.setChecked(                self.config.get("explorer", {}).get("enabled", True)            )            self.action_menu_enable.setChecked(                self.config.get("menu", {}).get("enabled", True)            )            self.action_menu_whitelist.setChecked(                self.config.get("menu", {}).get("whitelist_enabled", True)            )            # 写入 json + 重启后台            self.save_config()            self.restart_core()    def on_tray_settings_clicked(icon, item):        smartctrlv_main.open_global_settings_window()    def open_config_file(self):        if os.path.exists(CONFIG_PATH):            os.startfile(CONFIG_PATH)        else:            QMessageBox.warning(                None,                tr(self.lang, "msg_config_missing_title"),                tr(self.lang, "msg_config_missing", path=CONFIG_PATH),            )    def open_log_dir(self):        if os.path.isdir(LOG_DIR):            os.startfile(LOG_DIR)        else:            QMessageBox.warning(                None,                APP_NAME,                tr(self.lang, "msg_logdir_missing", path=LOG_DIR),            )    # ---------- 托盘菜单的开关行为 ----------    def on_toggle_explorer_enabled(self, checked: bool):        self.config.setdefault("explorer", {})["enabled"] = checked        self.save_config()        self.restart_core()    def on_toggle_menu_enabled(self, checked: bool):        self.config.setdefault("menu", {})["enabled"] = checked        self.save_config()        self.restart_core()    def on_toggle_menu_whitelist(self, checked: bool):        self.config.setdefault("menu", {})["whitelist_enabled"] = checked        self.save_config()        self.restart_core()    def on_toggle_autostart(self, checked: bool):        self.set_autostart_enabled(checked)    # ---------- 后台子进程管理 ----------    def get_core_script_path(self) -> str:        return os.path.join(SCRIPT_DIR, CORE_SCRIPT_NAME)    def start_core(self):        if self.core_proc and self.core_proc.poll() is None:            return        core_script = self.get_core_script_path()        if not os.path.exists(core_script):            QMessageBox.warning(                None,                APP_NAME,                tr(self.lang, "msg_core_not_found", name=CORE_SCRIPT_NAME),            )            return        try:            creationflags = 0            # 隐藏控制台窗口（在打包为 exe 时，可以改为不隐藏以便调试）            if os.name == "nt":                creationflags = getattr(subprocess, "CREATE_NO_WINDOW", 0)            self.core_proc = subprocess.Popen(                [sys.executable, core_script],                cwd=SCRIPT_DIR,                creationflags=creationflags,            )            print("[Tray] 已启动后台进程，PID =", self.core_proc.pid)        except Exception as e:            print("[Tray] 启动后台进程失败:", e)            traceback.print_exc()            QMessageBox.critical(                None,                APP_NAME,                tr(self.lang, "msg_core_start_failed", err=str(e)),            )            self.core_proc = None    def stop_core(self):        if not self.core_proc:            return        if self.core_proc.poll() is not None:            self.core_proc = None            return        try:            # 尝试优雅终止            if os.name == "nt":                self.core_proc.send_signal(signal.CTRL_BREAK_EVENT)            else:                self.core_proc.terminate()        except Exception:            pass        try:            self.core_proc.wait(timeout=2)        except Exception:            try:                self.core_proc.kill()            except Exception:                pass        print("[Tray] 后台进程已退出。")        self.core_proc = None    def restart_core(self):        if IS_FROZEN:            # exe 模式：直接重启 hooks 即可，不用子进程            try:                smartctrlv_main.stop_hooks()            except Exception:                pass            try:                smartctrlv_main.start_hooks()            except Exception:                pass        else:            self.stop_core()            self.start_core()    # ---------- 开机自启动 ----------    def get_autostart_reg_value(self) -> str:        """        在注册表 HKCU\Software\Microsoft\Windows\CurrentVersion\Run 下        使用 TRAY_APP_NAME 作为键名，值为启动本 tray 的命令。        """        python_exe = sys.executable        script_path = os.path.abspath(sys.argv[0])        return f'"{python_exe}" "{script_path}"'    def is_autostart_enabled(self) -> bool:        if winreg is None or os.name != "nt":            return False        try:            with winreg.OpenKey(                winreg.HKEY_CURRENT_USER,                r"Software\Microsoft\Windows\CurrentVersion\Run",                0,                winreg.KEY_READ,            ) as key:                try:                    value, _ = winreg.QueryValueEx(key, TRAY_APP_NAME)                    expected = self.get_autostart_reg_value()                    return value == expected                except FileNotFoundError:                    return False        except Exception:            return False    def set_autostart_enabled(self, enabled: bool):        if winreg is None or os.name != "nt":            QMessageBox.warning(                None,                APP_NAME,                tr(self.lang, "msg_autostart_not_supported"),            )            return        try:            with winreg.OpenKey(                winreg.HKEY_CURRENT_USER,                r"Software\Microsoft\Windows\CurrentVersion\Run",                0,                winreg.KEY_ALL_ACCESS,            ) as key:                if enabled:                    value = self.get_autostart_reg_value()                    winreg.SetValueEx(key, TRAY_APP_NAME, 0, winreg.REG_SZ, value)                    print("[Tray] 已启用开机自启动。")                else:                    try:                        winreg.DeleteValue(key, TRAY_APP_NAME)                        print("[Tray] 已取消开机自启动。")                    except FileNotFoundError:                        pass        except FileNotFoundError:            # 键不存在则创建            if enabled:                try:                    with winreg.CreateKey(                        winreg.HKEY_CURRENT_USER,                        r"Software\Microsoft\Windows\CurrentVersion\Run",                    ) as key:                        value = self.get_autostart_reg_value()                        winreg.SetValueEx(key, TRAY_APP_NAME, 0, winreg.REG_SZ, value)                        print("[Tray] 已创建并启用开机自启动。")                except Exception as e:                    print("[Tray] 设置开机自启动失败:", e)                    traceback.print_exc()        except Exception as e:            print("[Tray] 设置开机自启动失败:", e)            traceback.print_exc()            QMessageBox.warning(                None,                APP_NAME,                tr(self.lang, "msg_autostart_failed", err=str(e)),            )    # ---------- 退出 ----------    def exit_app(self):        # 清理后台和托盘        self.stop_core()        self.tray.hide()        QCoreApplication.quit()def main():    if os.name == "nt":        # 避免控制台关闭时整个进程被杀（在某些打包方式下有用）        try:            ctypes.windll.kernel32.SetConsoleCtrlHandler(None, True)        except Exception:            pass    app = QApplication(sys.argv)    app.setQuitOnLastWindowClosed(False)    tray_app = TrayApp(app)    sys.exit(app.exec())if __name__ == "__main__":    main()